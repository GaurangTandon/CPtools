{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    //
    // don't keep prefix  name similar to variable names or function names
    // as then typing the variable names brings up suggestions for snippets
    "Default contents of C++ file": {
        "prefix": "cppdefault",
        "body": [
            "#pragma GCC optimize \"O2\"", //Force GCC to enable O2 optimization
            // for io
            "#include <stdio.h>",
            // for sqrt and all
            "#include <math.h>",
            // for sorting and others
            "#include <algorithm>",
            // for basic linear,  2d, etc. data
            "#include <vector>",
            // don't mix cin/cout with sf/pf, causes problems :(
            // either use this or that but not both at once
            "#include <iostream>",
            // for simple string operations
            "#include <string>",
            "#include <map>",
            "#include <set>",
            "#include <queue>",
            "// for iota, accumulate, partial_sum",
            "// #include <numeric>",
            "// #include <iomanip>",
            "// #include <fstream>",
            "// #include <deque>",
            "// #include <cmath>",
            "// #include <unordered_map>",
            "// #include <utility>",
            "// #include <unordered_set>",
            "// #include <ctime>",
            "// #include <stack>",
            "// #include <bitset>",
            "// #include <random>",
            "// #include <cstring>",
            "// #include <cassert>",
            "// #include <complex>",
            "using namespace std;",
            "typedef unsigned long long int lu;",
            "typedef long long int ll;",
            "typedef long double ld;",
            // prefer to use the first definition
            "#define v vector<ll>",
            "#define vu vector<lu>",
            "#define vvu vector<vector<lu>>",
            "#define vld vector<ld>",
            "#define vs vector<string>",
            "#define pll pair<ll,ll>",
            "#define vpll vector<pair<ll,ll>>",
            "#define puu pair<lu,lu>",
            "#define vpuu vector<pair<lu,lu>>",
            "const lu MOD = 1000000007;",
            "const ld PI = 2 * acos(0.0);",
            // convenient method to ceil x/y
            // no need to cast into long double and
            // then call ceil, then cast  back into int
            // x,y must be ints though
            "#define round(x, y) ((x+y-1)/y)",
            "#define ce(x, y) ((x+y-1)/y)",
            "#define amax(x, y) if(y > x) x = y;",
            "#define amin(x, y) if(y < x) x = y;",
            "#define lcm(x, y) ((x) * (y) / __gcd(x, y))",
            // stupid seg fault for x.size() - 1 overflowing for empty x as x.size() is always unsigned
            "#define sz(x) (ll)x.size()",
            "#define len(x) (ll)x.length()",
            // useful when taking squares and cubes of larger expressions
            "#define sq(x) ((x) * (x))",
            "#define cb(x) ((x) * (x) * (x))",
            "",
            // so we can easily do sort(whole(x))
            // instead of sort(x.begin(), x.end())
            "#define all(x) x.begin(), x.end()",
            // for string to primitive conversions, use
            // stold, stod, stof, stoi, stol, stoll, stoul, stoull
            "",
            "v ga(ll n){",
            "    v a;",
            "    for(ll i = 0; i < n; i++){",
            "        ll p;",
            "        // scanf(\"%lld\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            "vu gau(lu n){",
            "    vu a;",
            "    for(lu i = 0; i < n; i++){",
            "        lu p;",
            "        // scanf(\"%lu\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "vs gas(lu n){",
            "    vs a;",
            "    for(lu i = 0; i < n; i++){",
            "        string p;",
            "        // scanf(\"%lu\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            // use template functions instead of overloading here ;)
            // "void pa(v a){",
            // "    for(ll p : a){",
            // "        // printf(\"%lld \", a[i]);",
            // "        cout << p << \" \";",
            // "    }",
            // "}",
            // "void pa(vu a){",
            // "    for(lu p : a){",
            // "        // printf(\"%lu \", a[i]);",
            // "        cout << p << \" \";",
            // "    }",
            // "}",
            "template <typename T, typename A>",
            "void pa(vector<T, A> const &a){",
            "    for(T p : a){",
            "        // printf(\"%lu \", a[i]);",
            "        cout << p << \" \";",
            "    }",
            "    cout << \"\\n\";",
            "}",
            "",
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}",
            "",
            "void solve(){",
            "    ${0:// code}",
            "}",
            "",
            "int main(void){",
            "    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
            // when you require to use this line just uncomment it
            "    ${1:// ll t;cin >> t;while(t--)}",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Default contents of a C++ file"
    },
    // size_t when compared with int gives incorrect results
    "non size_t loop": {
        "prefix": "ff",
        "body": ["for(${1:lu} ${2:i} = ${3:0}; $2 < ${4:n}; $2++){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "non size_t reverse loop": {
        "prefix": "fr",
        "body": ["for(${1:ll} ${2:i} = ${3:n} - 1; $2 >= ${4:0}; $2--){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "yes_no": {
        "prefix": "yesno",
        "body": [
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}"
        ],
        "description": "common yes no queries on cf"
    },
    "ceil and floor search": {
        "prefix": "ceflmethods",
        "body": [
            "template <typename T>",
            "// largest x st. a[x]==n",
            "ll ceilSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = ceilSearch(a, n, m + 1, e);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] < n)",
            "        return ceilSearch(a, n, m + 1, e);",
            "    else",
            "        return ceilSearch(a, n, s, m - 1);",
            "}",
            "",
            "template <typename T>",
            "// least x such that a[x]==n",
            "ll floorSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = floorSearch(a, n, s, m - 1);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] > n)",
            "    {",
            "        return floorSearch(a, n, s, m - 1);",
            "    }",
            "    else",
            "        return floorSearch(a, n, m + 1, e);",
            "}"
        ]
    },
    "leap year": {
        "prefix": "leapfr",
        "body": ["bool isLeap(lu y){", "    return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;", "}"],
        "description": ""
    },
    "Array functions": {
        "prefix": "arrmethods",
        "body": []
    },
    "infinities": {
        "prefix": "infs",
        "body": [
            // infinities that are big enough for
            // usual test cases but won't overflow
            // if you double them or add some constants
            "const int INT_INF = 0x3f3f3f3f;",
            // noe here that 2*LD_INF==LD_INF
            "const ld LD_ACTUAL_INF = 1.0l/0.0;",
            "const ld LD_INF = 1e15;", // Large double
            "const ld LD_EPS = 1e-8;", // Small double epsilon, used for computational geometry
            "int dbcmp(ld a, ld b) { return (fabsl(a - b) < LD_EPS) ? 0 : (a < b ? -1 : 1); }"
            // what for LL_INF and LU_INF?
        ]
    },
    "tests": {
        "prefix": "tests",
        "body": ["ll t;", "cin >> t;", "while(t--){", "    solve();", "}"]
    },
    "primes related methods": {
        "prefix": "prfunctions",
        "body": [
            "lu ${1:sieve}[${2:size}]; vu primes;",
            "",
            "void con(){",
            "    for(lu i = 2; i < $2; i++){",
            "         $1[i] = i;",
            "    }",
            "    for(lu i = 2; i < $2; i++){",
            "        if($1[i] == i){",
            "            primes.push_back(i);",
            "            for(lu j = i * 2; j < $2 && j > 0; j += i){",
            "                // retain below line if you wish to store smallest prime factor",
            "                ${3:if($1[j] == j)}",
            "                    $1[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "$0"
        ],
        "description": "generates a sieve in a global array, each element stores largest prime factor of that number"
    },
    "boolean sieve": {
        "prefix": "boolsieve",
        "body": [""],
        "description": "generates a boolean sieve in a global array"
    },
    "scanf": {
        "prefix": "sf",
        "body": "scanf(\"${1:%lu}\", ${0:&n});"
    },
    "printf": {
        "prefix": "pf",
        "body": "printf(\"${1:%lu}\", ${0:n});"
    },
    "cin": {
        "prefix": "ci",
        "body": ["cin >> $1;", "$0"]
    },
    "cout": {
        "prefix": "co",
        "body": ["cout << $1 << \"\\n\";", "$0"]
    },
    "ignore spaces/newlines after int input": {
        "prefix": "ignore",
        "body": "cin.ignore(256, '\\n');"
    },
    "split string": {
        "prefix": "splitstr",
        "body": [
            "vs splitstr(string s, char delim){",
            "    stringstream inputWay(s);",
            "    string dump;",
            "    vs ans;",
            "    while(getline(inputWay, dump, delim){",
            "     ans.push_back(dump);",
            "    }",
            "    return ans;",
            "}"
        ]
    },
    "cumsum": {
        "prefix": "cumsum",
        "body": [
            "${1:v} sum(${2:n});",
            "sum[0] = ${3:a}[0];",
            "for(lu i = 1; i < ${2}; i++){",
            "    sum[i] = sum[i - 1] + ${3}[i];",
            "}"
        ],
        "description": "generate simple prefix sum array for given integers"
    },
    "check if power of n": {
        "prefix": "powerofn",
        "body": [""]
    },

    "powersOfN": {
        "prefix": "powers",
        "body": [
            "// 2^35 is roughly 10^11",
            "const ll ${1:lim}=${2:35};",
            "vu powers(${1});",
            "// rest of this code goes into main, above is global",
            "powers.push_back(1);",
            "for(ll i = 1; i < ${1}; i++){",
            "    powers[i] = powers[i - 1] * 2;",
            "}"
        ]
    },
    "powerfunc": {
        "prefix": "power",
        "description": "two functions for x^y and x^y%mod",
        "body": [
            // avoid clash with pow inbuilt function
            "lu po(lu base, lu exp)",
            "{",
            "    lu result = 1;",
            "    for (;;)",
            "    {",
            "        if (exp & 1)",
            "            result *= base;",
            "        exp >>= 1;",
            "        if (!exp)",
            "            break;",
            "        base *= base;",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "lu pomod(lu x, lu y, lu mod)",
            "{",
            "    lu res = 1;",
            "    x = x % mod;",
            "",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res*x) % mod;",
            "        y = y >> 1;",
            "        x = (x * x) % mod;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "multiplication mod": {
        "prefix": "multmod",
        "body": [
            "${1:lu} multmod($1 a, $1 b, $1 mod){",
            "    if(a == 0 || b == 0) return 0;",
            "    if(b == 1) return a % mod;",
            "    if(b & 1) return (a + 2 * multmod(a, b / 2, mod)) % mod;",
            "    else return (2 * multmod(a, b / 2, mod)) % mod;",
            "}"
        ]
    },
    "methods related to factors of a number": {
        "prefix": "frmethods",
        "body": [
            // O(root N) algo to generate all factors of N
            // in ascending order
            "vu getFactors(lu a){",
            "    vu v1, v2;",
            "    for(lu i = 1, sq = (lu) sqrt(a); i <= sq; i++){",
            "        if(a % i == 0){",
            "            lu k = a / i;",
            "            if(i == k){",
            "                v1.push_back(i);",
            "            } else {",
            "                v1.push_back(i);",
            "                v2.push_back(k);",
            "            }",
            "        }",
            "    }",
            "    v1.insert(v1.end(), v2.rbegin(), v2.rend());",
            "    return move(v1);",
            "}",
            "",
            "lu countFactors(lu a){",
            "    // prerequisite is sieve array of all primes",
            "    lu c = 1, c2;",
            "    while(a != 1){",
            "        lu p = sieve[a];",
            "        c2 = 0;",
            "        while(p == sieve[a]){",
            "            c2++;",
            "            a /= p;",
            "        }",
            "        c *= (c2 + 1);",
            "    }",
            "    return c;",
            "}"
        ]
    },
    "rotation methods": {
        "body": [
            "// rotate segment of vector from a to b (inclusive) in dir",
            "// k times",
            "// dir = 0 left, dir = 1 right",
            // this is a neat wrapper over the underlying complicated rotate
            // STL method (requires <algorithm>)
            "void rot(vu &a, lu b, lu e, lu k = 1, int dir = 0){",
            "    k %= (e - b + 1);",
            "    if(dir) k = (e - b + 1) - k;    ",
            "    rotate(a.begin() + b, a.begin() + b + k, a.end() - (a.size() - e) + 1);",
            "}"
        ],
        "prefix": "rotmethods"
    },
    "max for n different variables": {
        "body": "??",
        "prefix": "??",
        "description": "max for n different variables, both via arguments and via an array (overload)"
    }
}
