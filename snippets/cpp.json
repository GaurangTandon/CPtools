{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    //
    // don't keep prefix  name similar to variable names or function names
    // as then typing the variable names brings up suggestions for snippets
    "Default contents of C++ file": {
        "prefix": "cppdefault",
        "body": [
            "#include <bits/stdc++.h>",
            // need endl on vscode otherwise it messes buffering on terminal
            "#ifdef ONLINE_JUDGE",
            "    #define endl \"\\n\"",
            "#endif",
            "using namespace std;",
            "typedef unsigned long long int lu;",
            "typedef long long int ll;",
            "typedef long double ld;",
            // prefer to use the first definition
            "typedef vector<ll> v;",
            "typedef vector<lu> vu;",
            "typedef vector<v> vv;",
            "typedef vector<vu> vvu;",
            "typedef vector<ld> vld;",
            "typedef vector<bool> vb;",
            "typedef vector<string> vs;",
            "typedef pair<ll,ll> pll;",
            "typedef vector<set<ll>> vsll;", // for adjacency list
            "typedef set<pair<ll,ll>> spll;",
            "typedef vector<spll> vspll;", // for weighted adjacency list
            "typedef vector<pll> vpll;",
            "typedef pair<lu,lu> puu;",
            "typedef vector<puu> vpuu;",
            "const ll MOD = 1000000007;",
            "const ld PI = 2 * acos(0.0);",
            "const v dx = {1, -1, 0, 0};",
            "const v dy = {0, 0, 1, -1};",
            // convenient method to ceil x/y
            // no need to cast into long double and
            // then call ceil, then cast  back into int
            // x,y must be ints though
            "#define round(x, y) ((x+y-1)/y)",
            "#define ce(x, y) ((x+y-1)/y)",
            "#define amax(x, y) if(y > x) x = y;",
            "#define amin(x, y) if(y < x) x = y;",
            "#define lcm(x, y) ((x) * (y) / __gcd(x, y))",
            // stupid seg fault for x.size() - 1 overflowing for empty x as x.size() is always unsigned
            "#define sz(x) (ll)x.size()",
            "#define len(x) (ll)x.length()",
            // useful when taking squares and cubes of larger expressions
            "#define sq(x) ((x) * (x))",
            "#define cb(x) ((x) * (x) * (x))",
            "#define noo {no(); return;}",
            "",
            // so we can easily do sort(whole(x))
            // instead of sort(x.begin(), x.end())
            "#define all(x) x.begin(), x.end()",
            // for string to primitive conversions, use
            // stold, stod, stof, stoi, stol, stoll, stoul, stoull
            "",
            "v ga(ll n, bool oneIndexed = false){",
            "    v a;",
            "    if(oneIndexed)",
            "        a.push_back(0ll);",
            "    for(ll i = 0; i < n; i++){",
            "        ll p;",
            "        // scanf(\"%lld\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            "vu gau(lu n, bool oneIndexed = false){",
            "    vu a;",
            "    if(oneIndexed)",
            "        a.push_back(0llu);",
            "    for(lu i = 0; i < n; i++){",
            "        lu p;",
            "        // scanf(\"%lu\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "vs gas(lu n, bool oneIndexed = false){",
            "    vs a;",
            "    if(oneIndexed)",
            "        a.push_back(\"\");",
            "    for(lu i = 0; i < n; i++){",
            "        string p;",
            "        // scanf(\"%lu\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            "template <typename T, typename A>",
            "void pa(vector<T, A> const &a, ll begin = 0, ll end = -1){",
            "    if(end == -1) end = a.size() - 1;",
            "    for(ll i = begin; i <= end; i++){",
            "        // printf(\"%lu \", a[i]);",
            "        cout << a[i] << \" \";",
            "    }",
            "    cout << \"\\n\";",
            "}",
            "",
            "template <typename T, typename A>",
            "void papair(vector<T, A> const &a, ll begin = 0, ll end = -1){",
            "    if(end == -1) end = a.size() - 1;",
            "    for(ll i = begin; i <= end; i++){",
            "        // printf(\"%lu \", a[i]);",
            "        cout << a[i].first << \" \" << a[i].second << endl;",
            "    }",
            "    cout << \"\\n\";",
            "}",
            "",
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "    // cout << -1 <<endl;",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}",
            "",
            "void solve(){",
            "    ${0:// code}",
            "}",
            "",
            "int main(void){",
            "    #ifndef ONLINE_JUDGE",
            "        // freopen(\"inp.txt\", \"r\", stdin);",
            "    #endif",
            "    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
            // when you require to use this line just uncomment it
            "    ${1:// ll t;cin >> t;while(t--)}",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Default contents of a C++ file"
    },
    // size_t when compared with int gives incorrect results
    "non size_t loop": {
        "prefix": "ff",
        "body": ["for(${1:ll} ${2:i} = ${3:0}; $2 < ${4:n}; $2++){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "non size_t reverse loop": {
        "prefix": "fr",
        "body": ["for(${1:ll} ${2:i} = ${3:n - 1}; $2 >= ${4:0}; $2--){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "yes_no": {
        "prefix": "yesno",
        "body": [
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}"
        ],
        "description": "common yes no queries on cf"
    },
    "ceil and floor search": {
        "prefix": "ceflmethods",
        "body": [
            "template <typename T>",
            "// largest x st. a[x]==n",
            "ll ceilSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = ceilSearch(a, n, m + 1, e);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] < n)",
            "        return ceilSearch(a, n, m + 1, e);",
            "    else",
            "        return ceilSearch(a, n, s, m - 1);",
            "}",
            "",
            "template <typename T>",
            "// least x such that a[x]==n",
            "ll floorSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = floorSearch(a, n, s, m - 1);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] > n)",
            "    {",
            "        return floorSearch(a, n, s, m - 1);",
            "    }",
            "    else",
            "        return floorSearch(a, n, m + 1, e);",
            "}"
        ]
    },
    "leap year": {
        "prefix": "leapfr",
        "body": ["bool isLeap(ll y){", "    return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;", "}"],
        "description": ""
    },
    "Array functions": {
        "prefix": "arrmethods",
        "body": []
    },
    "infinities": {
        "prefix": "infs",
        "body": [
            // infinities that are big enough for
            // usual test cases but won't overflow
            // if you double them or add some constants
            "const int INT_INF = 0x3f3f3f3f;",
            // noe here that 2*LD_INF==LD_INF
            "const ld LD_ACTUAL_INF = 1.0l/0.0;",
            "const ld LD_INF = 1e15;", // Large double
            "const ld LD_EPS = 1e-8;", // Small double epsilon, used for computational geometry
            "int dbcmp(ld a, ld b) { return (fabsl(a - b) < LD_EPS) ? 0 : (a < b ? -1 : 1); }"
            // what for LL_INF and LU_INF?
        ]
    },
    "tests": {
        "prefix": "tests",
        "body": ["ll t;", "cin >> t;", "while(t--){", "    solve();", "}"]
    },
    "primes related methods": {
        "prefix": "primemethods",
        "body": [
            "ll ${1:sieve}[${2:size}]; v primes;",
            "",
            "void con(){",
            "    for(ll i = 2; i < $2; i++){",
            "         $1[i] = i;",
            "    }",
            "    for(ll i = 2; i < $2; i++){",
            "        if($1[i] == i){",
            "            primes.push_back(i);",
            "            for(ll j = i * 2; j < $2 && j > 0; j += i){",
            "                // retain below line if you wish to store smallest prime factor",
            "                ${3:if($1[j] == j)}",
            "                    $1[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "$0"
        ],
        "description": "generates a sieve in a global array, each element stores largest prime factor of that number"
    },
    "boolean sieve": {
        "prefix": "boolsieve",
        "body": [""],
        "description": "generates a boolean sieve in a global array"
    },
    "scanf": {
        "prefix": "sf",
        "body": "scanf(\"${1:%lld}\", ${0:&n});"
    },
    "printf": {
        "prefix": "pf",
        "body": "printf(\"${1:%lld}\", ${0:n});"
    },
    "cin": {
        "prefix": "ci",
        "body": ["cin >> $1;", "$0"]
    },
    "cout": {
        "prefix": "co",
        "body": ["cout << $1 << \"\\n\";", "$0"]
    },
    "ignore spaces/newlines after int input": {
        "prefix": "ignore",
        "body": "cin.ignore(256, '\\n');"
    },
    "split string": {
        "prefix": "splitstr",
        "body": [
            "vs splitstr(string s, char delim = ' '){",
            "    stringstream inputWay(s);",
            "    string dump;",
            "    vs ans;",
            "    while(getline(inputWay, dump, delim)){",
            "     ans.push_back(dump);",
            "    }",
            "    return ans;",
            "}"
        ]
    },
    "cumsum": {
        "prefix": "cumsum",
        "body": [
            "${1:v} sum(${2:n});",
            "sum[0] = ${3:a}[0];",
            "for(ll i = 1; i < ${2}; i++){",
            "    sum[i] = sum[i - 1] + ${3}[i];",
            "}"
        ],
        "description": "generate simple prefix sum array for given integers"
    },
    "check if power of n": {
        "prefix": "powerofn",
        "body": [""]
    },

    "powersOfN": {
        "prefix": "powergenerator",
        "body": [
            "// 2^35 is roughly 10^11",
            "const ll ${1:lim}=${2:35};",
            "vu powers(${1});",
            "// rest of this code goes into main, above is global",
            "powers[0] = 1;",
            "for(ll i = 1; i < ${1}; i++){",
            "    powers[i] = powers[i - 1] * 2;",
            "}"
        ]
    },
    "powerfunc": {
        "prefix": "powermethods",
        "description": "two functions for x^y and x^y%mod",
        "body": [
            // avoid clash with pow inbuilt function
            "template<typename T>",
            "T po(T base, T exp)",
            "{",
            "    T result = 1;",
            "    for (;;)",
            "    {",
            "        if (exp & 1)",
            "            result *= base;",
            "        exp >>= 1;",
            "        if (!exp)",
            "            break;",
            "        base *= base;",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "template<typename T>",
            "T pomod(T x, T y, T mod)",
            "{",
            "    T res = 1;",
            "    x = x % mod;",
            "",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res*x) % mod;",
            "        y = y >> 1;",
            "        x = (x * x) % mod;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "multiplication mod": {
        "prefix": "multmod",
        "body": [
            "template<typename T>",
            "T multmod(T a, T b, T mod){",
            "    if(a == 0 || b == 0) return 0;",
            "    if(b == 1) return a % mod;",
            "    if(b & 1) return (a + 2 * multmod(a, b / 2, mod)) % mod;",
            "    else return (2 * multmod(a, b / 2, mod)) % mod;",
            "}"
        ]
    },
    "methods related to factors of a number": {
        "prefix": "factormethods",
        "body": [
            "#define SZE (ll)1e7 + 10",
            "ll sieve[SZE];",
            "v primes;",
            "",
            "void con()",
            "{",
            "    for (ll i = 2; i < SZE; i++)",
            "    {",
            "        sieve[i] = i;",
            "    }",
            "    for (ll i = 2; i < SZE; i++)",
            "    {",
            "        if (sieve[i] == i)",
            "        {",
            "            primes.push_back(i);",
            "            for (ll j = i * 2; j < SZE && j > 0; j += i)",
            "            {",
            "                // retain below line if you wish to store smallest prime factor",
            "                if (sieve[j] == j)",
            "                    sieve[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "// sieve should store smallest prime factor for each number",
            "vpll primeFactorize(ll n)",
            "{",
            "    vpll pfactors;",
            "    if (n >= SZE)",
            "    {",
            "        ll s = sqrt(n);",
            "",
            "        for (ll i = 0; i < sz(primes) && primes[i] <= s; i++)",
            "        {",
            "            if (n % primes[i] == 0)",
            "            {",
            "                ll p = primes[i];",
            "                ll c = 0;",
            "                while (n > 1 && n % p == 0)",
            "                {",
            "                    n /= p;",
            "                    c++;",
            "                }",
            "                if (c > 0)",
            "                    pfactors.push_back({p, c});",
            "                if (n < SZE)",
            "                {",
            "                    vpll x = primeFactorize(n);",
            "                    for (ll i = 0; i < sz(x); i++)",
            "                        pfactors.push_back(x[i]);",
            "                    return pfactors;",
            "                }",
            "            }",
            "        }",
            "        pfactors.push_back({n, 1});",
            "        return pfactors;",
            "    }",
            "    while (n > 1)",
            "    {",
            "        ll p = sieve[n];",
            "        ll c = 0;",
            "        while (n > 1 && n % p == 0)",
            "        {",
            "            n /= p;",
            "            c++;",
            "        }",
            "        if (c > 0)",
            "            pfactors.push_back({p, c});",
            "    }",
            "",
            "    return pfactors;",
            "}",
            "v factors;",
            "",
            "void getAllFactorsRecur(ll curr, ll primeIdx, const vpll &primeFactors)",
            "{",
            "    if (primeIdx == sz(primeFactors))",
            "    {",
            "        // curr is the factor, remember to sort your final vector!",
            "        // factors.push_back(curr);",
            "        return;",
            "    }",
            "    ll ans = 1, p = primeFactors[primeIdx].first, c = primeFactors[primeIdx].second;",
            "    for (ll i = 0; i <= c; i++)",
            "    {",
            "        getAllFactorsRecur(ans * curr, primeIdx + 1, primeFactors);",
            "        ans *= p;",
            "    }",
            "}"
        ]
    },
    "isvowel": {
        "prefix": "isvowel",
        "body": ["bool isVowel(char x){", "    return x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u';", "}"]
    },
    "split into segs by frequency": {
        "prefix": "makesegments",
        "description": "make segments based on {number, frequency}",
        "body": [
            "vv segs;",
            "for (ll i = 0; i < n; i++)",
            "{",
            "    ll c = 1;",
            "    while (i < n - 1 && a[i] == a[i + 1])",
            "    {",
            "        i++;",
            "        c++;",
            "    }",
            "    segs.push_back({a[i], c});",
            "}"
        ]
    },
    "rotation methods": {
        "body": [
            "// rotate segment of vector from a to b (inclusive) in dir",
            "// k times",
            "// dir = 0 left, dir = 1 right",
            // this is a neat wrapper over the underlying complicated rotate
            // STL method (requires <algorithm>)
            "template<typename T>",
            "void rot(vector<T> &a, T b, T e, T k = 1, T dir = 0){",
            "    k %= (e - b + 1);",
            "    if(dir) k = (e - b + 1) - k;    ",
            "    rotate(a.begin() + b, a.begin() + b + k, a.end() - (a.size() - e) + 1);",
            "}"
        ],
        "prefix": "rotmethods"
    },
    "compare two string values": {
        "body": [
            "/**",
            " * compare string a with string b numerically */",
            "bool alessthanb(string a, string b)",
            "{",
            "    if (b.size() > a.size())",
            "        return true;",
            "    else if (b.size() < a.size())",
            "        return false;",
            "",
            "    for (lu i = 0; i < a.size(); i++)",
            "    {",
            "        if (a[i] < b[i])",
            "            return true;",
            "        else if (a[i] > b[i])",
            "            return false;",
            "    }",
            "",
            "    return false; // both equal",
            "}"
        ],
        "prefix": "compmethods",
        "description": "compare two large strings as integers"
    },
    "max for n different variables": {
        "body": "??",
        "prefix": "??",
        "description": "max for n different variables, both via arguments and via an array (overload)"
    },
    "sorting for vvu type data": {
        "body": "sort(all(${1:a}), [](auto a, auto b) {\nreturn a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\n});",
        "prefix": "sorter"
    },
    "graph traversal for all connected components": {
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vv adjList(n + 1, v(0));",
            "// vector<vector<bool>> adjMat(n + 1, vector<bool>(n + 1, false));",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b;",
            "    cin >> a >> b;",
            "    // adjMat[a][b] = true;",
            "    // adjMat[b][a] = true;",
            "    adjList[a].push_back(b);",
            "    adjList[b].push_back(a);",
            "}",
            "",
            "v visited(n + 1, 0);",
            "",
            "for (ll i = 1; i <= n; i++)",
            "{",
            "    if(visited[i])",
            "        continue;",
            "    deque<lu> q;",
            "    q.push_back(i);",
            "    // keep track of all visited nodes",
            "    set<lu> visits;",
            "",
            "    visited[i] = 1;",
            "",
            "    while (!q.empty())",
            "    {",
            "        ll x = q[0];",
            "        q.pop_front();",
            "        visits.insert(x);",
            "",
            "        for (auto p : adjList[x])",
            "        {",
            "            if (!visited[p])",
            "            {",
            "                visited[p] = 1;",
            "                q.push_back(p);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "prefix": "graphtraversal"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "#define MAX (ll)3e5",
            "v visited(MAX, 0);",
            "v parents(MAX);",
            "v depths(MAX);",
            "void dfs(vv &adjList, ll curr, ll prev, ll depth)",
            "{",

            "    visited[curr] = 1;",
            "    for (auto neigh : adjList[curr])",
            "    {",
            "        if (neigh == prev) continue;",
            "        if (visited[neigh] == 0)",
            "        {",
            "            // parents[neigh] = curr;",
            "            dfs(adjList, neigh, curr, dpeth + 1);",
            "        }",
            "        else if (visited[neigh] == 1) {",
            "            ll cycleSize = depths[]",
            "        }",
            "    }",
            "    visited[curr] = 2;",
            "}"
        ]
    },
    "string input": {
        "prefix": "inpstring",
        "body": ["string s;", "cin >> s;", "ll n = sz(s);"]
    },
    "mirror chars": {
        "prefix": "mirrorcharlist",
        "body": [
            "map<char, char> otherMirror;",
            "set<char> selfMirrors;",
            "selfMirrors.insert('A');",
            "selfMirrors.insert('H');",
            "selfMirrors.insert('I');",
            "selfMirrors.insert('M');",
            "selfMirrors.insert('O');",
            "selfMirrors.insert('T');",
            "selfMirrors.insert('U');",
            "selfMirrors.insert('V');",
            "selfMirrors.insert('W');",
            "selfMirrors.insert('X');",
            "selfMirrors.insert('Y');",
            "selfMirrors.insert('o');",
            "selfMirrors.insert('o');",
            "selfMirrors.insert('v');",
            "selfMirrors.insert('w');",
            "selfMirrors.insert('x');",
            "",
            "otherMirror['b'] = 'd';",
            "otherMirror['p'] = 'q';",
            "otherMirror['d'] = 'b';",
            "otherMirror['q'] = 'p';"
        ]
    },
    "bfs flood fill": {
        "prefix": "bfsfloodfill",
        "body": [
            "void fillNeighbours(ll i, ll j, char x)",
            "{",
            "    queue<pair<ll, ll>> proc;",
            "    proc.push({i, j});",
            "    while (!proc.empty())",
            "    {",
            "        auto z = proc.front();",
            "        i = z.first;",
            "        j = z.second;",
            "        proc.pop();",
            "",
            "        if (i > n - 1 || i < 0 || j < 0 || j > m - 1)",
            "            continue;",
            "        if (grid[i][j] != '.')",
            "            continue;",
            "        grid[i][j] = x;",
            "        proc.push({i, j - 1});",
            "        proc.push({i, j + 1});",
            "        proc.push({i + 1, j});",
            "        proc.push({i - 1, j});",
            "    }",
            "}"
        ]
    },
    "trie": {
        "prefix": "TRIE",
        "body": [
            "#define RANGE 26",
            "#define BASE 'a'",
            "",
            "template <typename T>",
            "class TrieNode",
            "{",
            "    ll val;",
            "    ll numofEnds; // num of values that ended at this node",
            "    vector<TrieNode *> p;",
            "",
            "  private:",
            "    vector<char> getVectorOfString(const string &s)",
            "    {",
            "        vector<char> vc;",
            "        for (const auto &c : s)",
            "            vc.push_back(c);",
            "        return move(vc);",
            "    }",
            "",
            "  public:",
            "    TrieNode(ll value)",
            "    {",
            "        val = value;",
            "        p = vector<TrieNode *>(RANGE);",
            "        for (ll i = 0; i < RANGE; i++)",
            "            this->p[i] = NULL;",
            "    }",
            "",
            "    void insert(const vector<T> &vals)",
            "    {",
            "        TrieNode *currNode = this;",
            "        ll i = 0;",
            "        while (i < sz(vals))",
            "        {",
            "            ll a = vals[i] - BASE;",
            "            if (!currNode->p[a])",
            "                currNode->p[a] = new TrieNode(vals[i]);",
            "            currNode = currNode->p[a];",
            "            i++;",
            "        }",
            "        currNode->numofEnds++;",
            "    }",
            "",
            "    void insert(string s)",
            "    {",
            "        insert(getVectorOfString(s));",
            "    }",
            "",
            "    /** ",
            "     * Precondition: vals exists in Trie before erasure",
            "    */",
            "    void erase(const vector<T> &vals)",
            "    {",
            "        TrieNode *currNode = this;",
            "        TrieNode *prevNode = this;",
            "        ll i = 0, a;",
            "        while (i < sz(vals))",
            "        {",
            "            a = vals[i] - BASE;",
            "            prevNode = currNode;",
            "            currNode = currNode->p[a];",
            "            i++;",
            "        }",
            "        currNode->numofEnds--;",
            "        if (currNode->numofEnds == 0)",
            "            prevNode->p[a] = NULL;",
            "    }",
            "    void erase(string s)",
            "    {",
            "        erase(getVectorOfString(s));",
            "    }",
            "};",
            "",
            "TrieNode<ll> *root = new TrieNode<ll>(0ll);"
        ]
    },
    "kmp": {
        "prefix": "kmpalgo",
        "body": [
            "/**",
            " * You specify your own container, whether it be vector or string",
            " * or whatever",
            "*/",
            "template <class C>",
            "class KMP",
            "{",
            "    C pattern;",
            "    // longest prefix which is also suffix",
            "    v lps;",
            "",
            "  public:",
            "    KMP(const C &pattern)",
            "    {",
            "        preprocess(pattern);",
            "    }",
            "",
            "    void preprocess(const C &patt)",
            "    {",
            "        pattern = patt;",
            "        ll n = patt.size();",
            "        lps = v(n, 0);",
            "",
            "        // j is current position in string",
            "        // i is length of current longest prefix (which is also a suffix)",
            "        ll i = 0;",
            "        for (ll j = 1; j < n; j++)",
            "        {",
            "            while (i > 0 && patt[i] != patt[j])",
            "                i = lps[i];",
            "            if (patt[j] == patt[i])",
            "                i++;",
            "            lps[j] = i;",
            "        }",
            "    }",
            "",
            "    v getMatchIndices(const C &text)",
            "    {",
            "        ll lenPatternMatch = 0,",
            "           textIndex = 0;",
            "        v matches;",
            "",
            "        while (textIndex < sz(text))",
            "        {",
            "            // cout << lenPatternMatch << \" \" << textIndex << endl;",
            "            if (text[textIndex] == pattern[lenPatternMatch])",
            "            {",
            "                lenPatternMatch++;",
            "                textIndex++;",
            "                if (lenPatternMatch == sz(pattern))",
            "                {",
            "                    matches.push_back(textIndex - lenPatternMatch + 1);",
            "                    lenPatternMatch = lps[lenPatternMatch - 1];",
            "                }",
            "            }",
            "            else",
            "            {",
            "                if (lenPatternMatch > 0)",
            "                    lenPatternMatch = lps[lenPatternMatch - 1];",
            "                else",
            "                    textIndex++;",
            "            }",
            "        }",
            "",
            "        return move(matches);",
            "    }",
            "",
            "    ll count(const C &text)",
            "    {",
            "        return sz(getMatchIndices(text));",
            "    }",
            "",
            "    bool matches(const C &text)",
            "    {",
            "        return count(text) > 0;",
            "    }",
            "};"
        ]
    },
    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "// ONE INDEXED, independent nodes given by weights[i] <= 0",
            "v weights(5e5, 0);",
            "",
            "ll finder(ll v1)",
            "{",
            "    if (weights[v1] > 0)",
            "        weights[v1] = finder(weights[v1]);",
            "    if (weights[v1] > 0)",
            "        return weights[v1];",
            "    return v1;",
            "}",
            "",
            "void unioner(ll v1, ll v2)",
            "{",
            "    v1 = finder(v1);",
            "    v2 = finder(v2);",
            "",
            "    if (-weights[v1] >= -weights[v2])",
            "    {",
            "        weights[v1] += weights[v2] - 1;",
            "        weights[v2] = v1;",
            "    }",
            "    else",
            "    {",
            "        weights[v2] += weights[v1] - 1;",
            "        weights[v1] = v2;",
            "    }",
            "}",
            "",
            "bool addEdge(ll v1, ll v2, spll &edges)",
            "{",
            "    ll x1 = finder(v1),",
            "        x2 = finder(v2);",
            "    if (x1 != x2)",
            "    {",
            "        edges.insert({v1, v2});",
            "        unioner(x1, x2);",
            "        return true;",
            "    }",
            "    return false;",
            "}"
        ]
    },
    "graphinput": {
        "prefix": "graphinput",
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vv adjList(n + 1, v(0));",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b;",
            "    cin >> a >> b;",
            "    adjList[a].push_back(b);",
            "    adjList[b].push_back(a);",
            "}"
        ]
    },
    "graphinputweighted": {
        "prefix": "graphinputw",
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vspll adjList(n + 1);",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b, c;",
            "    cin >> a >> b >> c;",
            "    adjList[a].insert({b, c});",
            "    adjList[b].insert({a, c});",
            "}"
        ]
    },
    "toposort": {
        "prefix": "toposort",
        "body": [
            "queue<ll> degrees;",
            "for (ll i = 1; i <= n; i++)",
            "    if (!indeg[i])",
            "        degrees.push(i);",
            "v toposort = {};",
            "while (!degrees.empty())",
            "{",
            "    auto node = degrees.front();",
            "    degrees.pop();",
            "    toposort.push_back(node);",
            "    for (auto neigh : adjList[node])",
            "    {",
            "        indeg[neigh]--;",
            "        if (!indeg[neigh])",
            "            degrees.push(neigh);",
            "    }",
            "}"
        ]
    },
    "djikstra": {
        "prefix": "djikstra",
        "body": [
            "priority_queue<pll, vector<pll>, greater<pll>> q;",
            "v parent(5e5, -1);",
            "v distances(5e5, 1e15);",
            "vb visited(5e5, false);",
            "void djikstra(ll src, const vspll &adjList)",
            "{",
            "    distances[src] = 0;",
            "    q.push({0, src});",
            "    ll n = sz(adjList) - 1;",
            "",
            "    while (!q.empty())",
            "    {",
            "        auto x = q.top();",
            "        auto node = x.second;",
            "        auto d = distances[node];",
            "        q.pop();",
            "",
            "        if (visited[node])",
            "            continue;",
            "        visited[node] = true;",
            "",
            "        for (const auto &neigh : adjList[node])",
            "        {",
            "            ll d2 = d + neigh.second;",
            "",
            "            if (distances[neigh.first] > d2)",
            "            {",
            "                distances[neigh.first] = d2;",
            "                parent[neigh.first] = node;",
            "                q.push({d2, neigh.first});",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "shortest path tree": {
        "prefix": "sptree",
        "body": [
            "vv sptree(n + 1);",
            "for (ll i = 1; i <= n; i++)",
            "{",
            "    if (parent[i])",
            "    {",
            "        sptree[i].push_back(parent[i]);",
            "        sptree[parent[i]].push_back(i);",
            "    }",
            "}"
        ]
    },
    "dfs if part of cycle": {
        "prefix": "dfspartofcycle",
        "body": [
            "#define MAX (ll)3e5",
            "v visited(MAX, 0);",
            "v partofcycle(MAX, 0);",
            "v cyclenodes;",
            "bool dfs(vv &adjList, ll curr, ll prev)",
            "{",
            "    visited[curr] = 1;",
            "    for (auto neigh : adjList[curr])",
            "    {",
            "        if (neigh == prev)",
            "            continue;",
            "        if (visited[neigh] == 0)",
            "        {",
            "            if (dfs(adjList, neigh, curr))",
            "            {",
            "                partofcycle[curr] = true;",
            "                if (curr == cyclenodes.back())",
            "                {",
            "                    cyclenodes.pop_back();",
            "                    return false;",
            "                }",
            "                else",
            "                    return true;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            partofcycle[curr] = true;",
            "            cyclenodes.push_back(neigh);",
            "            return true;",
            "        }",
            "    }",
            "    return false;",
            "}"
        ]
    }
}
