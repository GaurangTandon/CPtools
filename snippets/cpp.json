{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    //
    // don't keep prefix  name similar to variable names or function names
    // as then typing the variable names brings up suggestions for snippets
    "Default contents of C++ file": {
        "prefix": "cppdefault",
        "body": [
            "#include <bits/stdc++.h>",
            // need endl on vscode otherwise it messes buffering on terminal
            "#ifdef ONLINE_JUDGE",
            "    #define endl \"\\n\"",
            "#endif",
            "using namespace std;",
            "typedef unsigned long long int lu;",
            "typedef long long int ll;",
            "typedef long double ld;",
            // prefer to use the first definition
            "typedef vector<ll> v;",
            "typedef vector<lu> vu;",
            "typedef vector<v> vv;",
            "typedef vector<vu> vvu;",
            "typedef vector<ld> vld;",
            "typedef vector<bool> vb;",
            "typedef vector<string> vs;",
            "typedef pair<ll,ll> pll;",
            "typedef vector<set<ll>> vsll;", // for adjacency list
            "typedef set<pair<ll,ll>> spll;",
            "typedef vector<spll> vspll;", // for weighted adjacency list
            "typedef vector<pll> vpll;",
            "typedef pair<lu,lu> puu;",
            "typedef vector<puu> vpuu;",
            "const ll MOD = 1000000007;",
            "const ld PI = 2 * acos(0.0);",
            "const v dx = {1, -1, 0, 0};",
            "const v dy = {0, 0, 1, -1};",
            // convenient method to ceil x/y
            // no need to cast into long double and
            // then call ceil, then cast  back into int
            // x,y must be ints though
            "#define round(x, y) ((x+y-1)/y)",
            "#define ce(x, y) ((x+y-1)/y)",
            "#define amax(x, y) if(y > x) x = y;",
            "#define amin(x, y) if(y < x) x = y;",
            "#define lcm(x, y) ((x) * (y) / __gcd(x, y))",
            // stupid seg fault for x.size() - 1 overflowing for empty x as x.size() is always unsigned
            "#define sz(x) (ll)x.size()",
            "#define len(x) (ll)x.length()",
            // useful when taking squares and cubes of larger expressions
            "#define sq(x) ((x) * (x))",
            "#define cb(x) ((x) * (x) * (x))",
            "#define noo {no(); return;}",
            "",
            // so we can easily do sort(whole(x))
            // instead of sort(x.begin(), x.end())
            "#define all(x) x.begin(), x.end()",
            // for string to primitive conversions, use
            // stold, stod, stof, stoi, stol, stoll, stoul, stoull
            "",
            "v ga(ll n, bool oneIndexed = false){",
            "    v a;",
            "    if(oneIndexed)",
            "        a.push_back(0ll);",
            "    for(ll i = 0; i < n; i++){",
            "        ll p;",
            "        // scanf(\"%lld\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            "vs gas(lu n, bool oneIndexed = false){",
            "    vs a;",
            "    if(oneIndexed)",
            "        a.push_back(\"\");",
            "    for(lu i = 0; i < n; i++){",
            "        string p;",
            "        // scanf(\"%lu\", &p);",
            "        cin >> p;",
            "        a.push_back(p);",
            "    }",
            "    return move(a);",
            "}",
            "",
            "template <typename T, typename A>",
            "void pa(vector<T, A> const &a, ll begin = 0, ll end = -1){",
            "    if(end == -1) end = sz(a) - 1;",
            "    for(ll i = begin; i <= end; i++){",
            "        // printf(\"%lu \", a[i]);",
            "        cout << a[i] << \" \";",
            "    }",
            "    cout << endl;",
            "}",
            "",
            "template <typename T, typename A>",
            "void papair(vector<T, A> const &a, ll begin = 0, ll end = -1){",
            "    if(end == -1) end = sz(a) - 1;",
            "    for(ll i = begin; i <= end; i++){",
            "        // printf(\"%lu \", a[i]);",
            "        cout << a[i].first << \" \" << a[i].second << endl;",
            "    }",
            "}",
            "",
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "    // cout << -1 <<endl;",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}",
            "",
            "void solve(){",
            "    ${0:// code}",
            "}",
            "",
            "int main(void){",
            "    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
            // when you require to use this line just uncomment it
            "    ${1:// ll t;cin >> t;while(t--)}",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Default contents of a C++ file"
    },
    // size_t when compared with int gives incorrect results
    "non size_t loop": {
        "prefix": "ff",
        "body": ["for(${1:ll} ${2:i} = ${3:0}; $2 < ${4:n}; $2++){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "non size_t reverse loop": {
        "prefix": "fr",
        "body": ["for(${1:ll} ${2:i} = ${3:n - 1}; $2 >= ${4:0}; $2--){", "    ${0:// code}", "}"],
        "description": "Default contents of a C file"
    },
    "yes_no": {
        "prefix": "yesno",
        "body": [
            "void yes() {",
            "    cout << \"YES\\n\";",
            "}",

            "",
            "void no() {",
            "    cout << \"NO\\n\";",
            "}",
            "",
            "void yesno(int f){",
            "    if(f) yes(); else no();",
            "}"
        ],
        "description": "common yes no queries on cf"
    },
    "ceil and floor search": {
        "prefix": "ceflmethods",
        "body": [
            "template <typename T>",
            "// largest x st. a[x]==n",
            "ll ceilSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = ceilSearch(a, n, m + 1, e);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] < n)",
            "        return ceilSearch(a, n, m + 1, e);",
            "    else",
            "        return ceilSearch(a, n, s, m - 1);",
            "}",
            "",
            "template <typename T>",
            "// least x such that a[x]==n",
            "ll floorSearch(const vector<T> &a, T n, ll s, ll e)",
            "{",
            "    if (s > e || a[s] > n || a[e] < n)",
            "        return -1;",
            "",
            "    ll m = (s + e) / 2, idx;",
            "",
            "    if (a[m] == n)",
            "    {",
            "        idx = floorSearch(a, n, s, m - 1);",
            "        return idx == -1 ? m : idx;",
            "    }",
            "    else if (a[m] > n)",
            "    {",
            "        return floorSearch(a, n, s, m - 1);",
            "    }",
            "    else",
            "        return floorSearch(a, n, m + 1, e);",
            "}"
        ]
    },
    "leap year": {
        "prefix": "leapfr",
        "body": ["bool isLeap(ll y){", "    return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;", "}"],
        "description": ""
    },
    "Array functions": {
        "prefix": "arrmethods",
        "body": []
    },
    "infinities": {
        "prefix": "infs",
        "body": [
            // infinities that are big enough for
            // usual test cases but won't overflow
            // if you double them or add some constants
            "const int INT_INF = 0x3f3f3f3f;",
            // noe here that 2*LD_INF==LD_INF
            "const ld LD_ACTUAL_INF = 1.0l/0.0;",
            "const ld LD_INF = 1e15;", // Large double
            "const ld LD_EPS = 1e-8;", // Small double epsilon, used for computational geometry
            "int dbcmp(ld a, ld b) { return (fabsl(a - b) < LD_EPS) ? 0 : (a < b ? -1 : 1); }"
            // what for LL_INF and LU_INF?
        ]
    },
    "tests": {
        "prefix": "tests",
        "body": ["ll t;", "cin >> t;", "while(t--){", "    solve();", "}"]
    },
    "primes related methods": {
        "prefix": "primemethods",
        "body": [
            "ll ${1:sieve}[(ll)${2:size}]; v primes;",
            "",
            "void con(){",
            "    for(ll i = 2; i < $2; i++){",
            "         $1[i] = i;",
            "    }",
            "    for(ll i = 2; i < $2; i++){",
            "        if($1[i] == i){",
            "            primes.push_back(i);",
            "            for(ll j = i * 2; j < $2 && j > 0; j += i){",
            "                // retain below line if you wish to store smallest prime factor",
            "                ${3:if($1[j] == j)}",
            "                    $1[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "$0"
        ],
        "description": "generates a sieve in a global array, each element stores largest prime factor of that number"
    },
    "boolean sieve": {
        "prefix": "boolsieve",
        "body": [""],
        "description": "generates a boolean sieve in a global array"
    },
    "scanf": {
        "prefix": "sf",
        "body": "scanf(\"${1:%lld}\", ${0:&n});"
    },
    "printf": {
        "prefix": "pf",
        "body": "printf(\"${1:%lld}\", ${0:n});"
    },
    "cin": {
        "prefix": "ci",
        "body": ["cin >> $1;", "$0"]
    },
    "cout": {
        "prefix": "co",
        "body": ["cout << $1 << \"\\n\";", "$0"]
    },
    "ignore spaces/newlines after int input": {
        "prefix": "ignore",
        "body": "cin.ignore(256, '\\n');"
    },
    "split string": {
        "prefix": "splitstr",
        "body": [
            "vs splitstr(string s, char delim = ' '){",
            "    stringstream inputWay(s);",
            "    string dump;",
            "    vs ans;",
            "    while(getline(inputWay, dump, delim)){",
            "     ans.push_back(dump);",
            "    }",
            "    return ans;",
            "}"
        ]
    },
    "cumsum": {
        "prefix": "cumsum",
        "body": [
            "${1:v} sum(${2:n});",
            "sum[0] = ${3:a}[0];",
            "for(ll i = 1; i < ${2}; i++){",
            "    sum[i] = sum[i - 1] + ${3}[i];",
            "}"
        ],
        "description": "generate simple prefix sum array for given integers"
    },
    "check if power of n": {
        "prefix": "powerofn",
        "body": [""]
    },

    "powersOfN": {
        "prefix": "powergenerator",
        "body": [
            "// 2^35 is roughly 10^11",
            "const ll lim = 35;",
            "vu powers(lim);",
            "// rest of this code goes into main, above is global",
            "powers[0] = 1;",
            "for (ll i = 1; i < lim; i++) {",
            "    powers[i] = powers[i - 1] * 2;",
            "}"
        ]
    },
    "powerfunc": {
        "prefix": "powermethods",
        "description": "two functions for x^y and x^y%mod",
        "body": [
            // avoid clash with pow inbuilt function
            "template<typename T>",
            "T po(T base, T exp)",
            "{",
            "    T result = 1;",
            "    for (;;)",
            "    {",
            "        if (exp & 1)",
            "            result *= base;",
            "        exp >>= 1;",
            "        if (!exp)",
            "            break;",
            "        base *= base;",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "template<typename T>",
            "T pomod(T x, T y, T mod)",
            "{",
            "    T res = 1;",
            "    x = x % mod;",
            "",
            "    while (y > 0)",
            "    {",
            "        if (y & 1)",
            "            res = (res*x) % mod;",
            "        y = y >> 1;",
            "        x = (x * x) % mod;",
            "    }",
            "    return res;",
            "}"
        ]
    },
    "multiplication mod": {
        "prefix": "multmod",
        "body": [
            "template<typename T>",
            "T multmod(T a, T b, T mod){",
            "    if(a == 0 || b == 0) return 0;",
            "    if(b == 1) return a % mod;",
            "    if(b & 1) return (a + 2 * multmod(a, b / 2, mod)) % mod;",
            "    else return (2 * multmod(a, b / 2, mod)) % mod;",
            "}"
        ]
    },
    "methods related to factors of a number": {
        "prefix": "factormethods",
        "body": [
            "#define SZE (ll)1e7 + 10",
            "ll sieve[SZE];",
            "v primes;",
            "",
            "void con()",
            "{",
            "    for (ll i = 2; i < SZE; i++)",
            "    {",
            "        sieve[i] = i;",
            "    }",
            "    for (ll i = 2; i < SZE; i++)",
            "    {",
            "        if (sieve[i] == i)",
            "        {",
            "            primes.push_back(i);",
            "            for (ll j = i * 2; j < SZE && j > 0; j += i)",
            "            {",
            "                // retain below line if you wish to store smallest prime factor",
            "                if (sieve[j] == j)",
            "                    sieve[j] = i;",
            "            }",
            "        }",
            "    }",
            "}",
            "",
            "// sieve should store smallest prime factor for each number",
            "vpll primeFactorize(ll n)",
            "{",
            "    vpll pfactors;",
            "    if (n >= SZE)",
            "    {",
            "        ll s = sqrt(n);",
            "",
            "        for (ll i = 0; i < sz(primes) && primes[i] <= s; i++)",
            "        {",
            "            if (n % primes[i] == 0)",
            "            {",
            "                ll p = primes[i];",
            "                ll c = 0;",
            "                while (n > 1 && n % p == 0)",
            "                {",
            "                    n /= p;",
            "                    c++;",
            "                }",
            "                if (c > 0)",
            "                    pfactors.push_back({p, c});",
            "                if (n < SZE)",
            "                {",
            "                    vpll x = primeFactorize(n);",
            "                    for (ll i = 0; i < sz(x); i++)",
            "                        pfactors.push_back(x[i]);",
            "                    return pfactors;",
            "                }",
            "            }",
            "        }",
            "        pfactors.push_back({n, 1});",
            "        return pfactors;",
            "    }",
            "    while (n > 1)",
            "    {",
            "        ll p = sieve[n];",
            "        ll c = 0;",
            "        while (n > 1 && n % p == 0)",
            "        {",
            "            n /= p;",
            "            c++;",
            "        }",
            "        if (c > 0)",
            "            pfactors.push_back({p, c});",
            "    }",
            "",
            "    return pfactors;",
            "}",
            "v factors;",
            "",
            "void getAllFactorsRecur(ll curr, ll primeIdx, const vpll &primeFactors)",
            "{",
            "    if (primeIdx == sz(primeFactors))",
            "    {",
            "        // curr is the factor, remember to sort your final vector!",
            "        // factors.push_back(curr);",
            "        return;",
            "    }",
            "    ll ans = 1, p = primeFactors[primeIdx].first, c = primeFactors[primeIdx].second;",
            "    for (ll i = 0; i <= c; i++)",
            "    {",
            "        getAllFactorsRecur(ans * curr, primeIdx + 1, primeFactors);",
            "        ans *= p;",
            "    }",
            "}"
        ]
    },
    "isvowel": {
        "prefix": "isvowel",
        "body": ["bool isVowel(char x){", "    return x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u';", "}"]
    },
    "split into segs by frequency": {
        "prefix": "makesegments",
        "description": "make segments based on {number, frequency}",
        "body": [
            "vv segs;",
            "for (ll i = 0; i < n; i++)",
            "{",
            "    ll c = 1;",
            "    while (i < n - 1 && a[i] == a[i + 1])",
            "    {",
            "        i++;",
            "        c++;",
            "    }",
            "    segs.push_back({a[i], c});",
            "}"
        ]
    },
    "rotation methods": {
        "body": [
            "// rotate segment of vector from a to b (inclusive) in dir",
            "// k times",
            "// dir = 0 left, dir = 1 right",
            // this is a neat wrapper over the underlying complicated rotate
            // STL method (requires <algorithm>)
            "template<typename T>",
            "void rot(vector<T> &a, T b, T e, T k = 1, T dir = 0){",
            "    k %= (e - b + 1);",
            "    if(dir) k = (e - b + 1) - k;    ",
            "    rotate(a.begin() + b, a.begin() + b + k, a.end() - (a.size() - e) + 1);",
            "}"
        ],
        "prefix": "rotmethods"
    },
    "compare two string values": {
        "body": [
            "/**",
            " * compare string a with string b numerically */",
            "bool alessthanb(string a, string b)",
            "{",
            "    if (b.size() > a.size())",
            "        return true;",
            "    else if (b.size() < a.size())",
            "        return false;",
            "",
            "    for (lu i = 0; i < a.size(); i++)",
            "    {",
            "        if (a[i] < b[i])",
            "            return true;",
            "        else if (a[i] > b[i])",
            "            return false;",
            "    }",
            "",
            "    return false; // both equal",
            "}"
        ],
        "prefix": "compmethods",
        "description": "compare two large strings as integers"
    },
    "max for n different variables": {
        "body": "??",
        "prefix": "??",
        "description": "max for n different variables, both via arguments and via an array (overload)"
    },
    "sorting for vvu type data": {
        "body": "sort(all(${1:a}), [](auto a, auto b) {\n    return a[0] < b[0] || (a[0] == b[0] && a[1] < b[1]);\n});",
        "prefix": "sorter"
    },
    "graph traversal for all connected components": {
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vv adjList(n + 1, v(0));",
            "// vector<vector<bool>> adjMat(n + 1, vector<bool>(n + 1, false));",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b;",
            "    cin >> a >> b;",
            "    // adjMat[a][b] = true;",
            "    // adjMat[b][a] = true;",
            "    adjList[a].push_back(b);",
            "    adjList[b].push_back(a);",
            "}",
            "",
            "v visited(n + 1, 0);",
            "",
            "for (ll i = 1; i <= n; i++)",
            "{",
            "    if(visited[i])",
            "        continue;",
            "    deque<lu> q;",
            "    q.push_back(i);",
            "    // keep track of all visited nodes",
            "    set<lu> visits;",
            "",
            "    visited[i] = 1;",
            "",
            "    while (!q.empty())",
            "    {",
            "        ll x = q[0];",
            "        q.pop_front();",
            "        visits.insert(x);",
            "",
            "        for (auto p : adjList[x])",
            "        {",
            "            if (!visited[p])",
            "            {",
            "                visited[p] = 1;",
            "                q.push_back(p);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "prefix": "graphtraversal"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "#define MAX (ll)3e5",
            "v visited(MAX, 0);",
            "v parents(MAX);",
            "v depths(MAX);",
            "void dfs(vv &adjList, ll curr, ll prev, ll depth)",
            "{",

            "    visited[curr] = 1;",
            "    for (auto neigh : adjList[curr])",
            "    {",
            "        if (neigh == prev) continue;",
            "        if (visited[neigh] == 0)",
            "        {",
            "            // parents[neigh] = curr;",
            "            dfs(adjList, neigh, curr, dpeth + 1);",
            "        }",
            "        else if (visited[neigh] == 1) {",
            "            ll cycleSize = depths[]",
            "        }",
            "    }",
            "    visited[curr] = 2;",
            "}"
        ]
    },
    "string input": {
        "prefix": "inpstring",
        "body": ["string s;", "cin >> s;", "ll n = sz(s);"]
    },
    "mirror chars": {
        "prefix": "mirrorcharlist",
        "body": [
            "map<char, char> otherMirror;",
            "set<char> selfMirrors;",
            "selfMirrors.insert('A');",
            "selfMirrors.insert('H');",
            "selfMirrors.insert('I');",
            "selfMirrors.insert('M');",
            "selfMirrors.insert('O');",
            "selfMirrors.insert('T');",
            "selfMirrors.insert('U');",
            "selfMirrors.insert('V');",
            "selfMirrors.insert('W');",
            "selfMirrors.insert('X');",
            "selfMirrors.insert('Y');",
            "selfMirrors.insert('o');",
            "selfMirrors.insert('o');",
            "selfMirrors.insert('v');",
            "selfMirrors.insert('w');",
            "selfMirrors.insert('x');",
            "",
            "otherMirror['b'] = 'd';",
            "otherMirror['p'] = 'q';",
            "otherMirror['d'] = 'b';",
            "otherMirror['q'] = 'p';"
        ]
    },
    "bfs flood fill": {
        "prefix": "bfsfloodfill",
        "body": [
            "void fillNeighbours(ll i, ll j, char x)",
            "{",
            "    queue<pair<ll, ll>> proc;",
            "    proc.push({i, j});",
            "    while (!proc.empty())",
            "    {",
            "        auto z = proc.front();",
            "        i = z.first;",
            "        j = z.second;",
            "        proc.pop();",
            "",
            "        if (i > n - 1 || i < 0 || j < 0 || j > m - 1)",
            "            continue;",
            "        if (grid[i][j] != '.')",
            "            continue;",
            "        grid[i][j] = x;",
            "        proc.push({i, j - 1});",
            "        proc.push({i, j + 1});",
            "        proc.push({i + 1, j});",
            "        proc.push({i - 1, j});",
            "    }",
            "}"
        ]
    },
    "trie": {
        "prefix": "TRIE",
        "body": [
            "#define RANGE 26",
            "#define BASE 'a'",
            "",
            "template <typename T>",
            "class TrieNode",
            "{",
            "    ll val;",
            "    ll numofEnds; // num of values that ended at this node",
            "    vector<TrieNode *> p;",
            "",
            "  private:",
            "    vector<char> getVectorOfString(const string &s)",
            "    {",
            "        vector<char> vc;",
            "        for (const auto &c : s)",
            "            vc.push_back(c);",
            "        return move(vc);",
            "    }",
            "",
            "  public:",
            "    TrieNode(ll value)",
            "    {",
            "        val = value;",
            "        p = vector<TrieNode *>(RANGE);",
            "        for (ll i = 0; i < RANGE; i++)",
            "            this->p[i] = NULL;",
            "    }",
            "",
            "    void insert(const vector<T> &vals)",
            "    {",
            "        TrieNode *currNode = this;",
            "        ll i = 0;",
            "        while (i < sz(vals))",
            "        {",
            "            ll a = vals[i] - BASE;",
            "            if (!currNode->p[a])",
            "                currNode->p[a] = new TrieNode(vals[i]);",
            "            currNode = currNode->p[a];",
            "            i++;",
            "        }",
            "        currNode->numofEnds++;",
            "    }",
            "",
            "    void insert(string s)",
            "    {",
            "        insert(getVectorOfString(s));",
            "    }",
            "",
            "    /** ",
            "     * Precondition: vals exists in Trie before erasure",
            "    */",
            "    void erase(const vector<T> &vals)",
            "    {",
            "        TrieNode *currNode = this;",
            "        TrieNode *prevNode = this;",
            "        ll i = 0, a;",
            "        while (i < sz(vals))",
            "        {",
            "            a = vals[i] - BASE;",
            "            prevNode = currNode;",
            "            currNode = currNode->p[a];",
            "            i++;",
            "        }",
            "        currNode->numofEnds--;",
            "        if (currNode->numofEnds == 0)",
            "            prevNode->p[a] = NULL;",
            "    }",
            "    void erase(string s)",
            "    {",
            "        erase(getVectorOfString(s));",
            "    }",
            "};",
            "",
            "TrieNode<ll> *root = new TrieNode<ll>(0ll);"
        ]
    },
    "kmp": {
        "prefix": "kmpalgo",
        "body": [
            "/**",
            " * You specify your own container, whether it be vector or string",
            " * or whatever",
            "*/",
            "template <class C>",
            "class KMP",
            "{",
            "    C pattern;",
            "    // longest prefix which is also suffix",
            "    v lps;",
            "",
            "  public:",
            "    KMP(const C &pattern)",
            "    {",
            "        preprocess(pattern);",
            "    }",
            "",
            "    void preprocess(const C &patt)",
            "    {",
            "        pattern = patt;",
            "        ll n = patt.size();",
            "        lps = v(n, 0);",
            "",
            "        // j is current position in string",
            "        // i is length of current longest prefix (which is also a suffix)",
            "        ll i = 0;",
            "        for (ll j = 1; j < n; j++)",
            "        {",
            "            while (i > 0 && patt[i] != patt[j])",
            "                i = lps[i];",
            "            if (patt[j] == patt[i])",
            "                i++;",
            "            lps[j] = i;",
            "        }",
            "    }",
            "",
            "    v getMatchIndices(const C &text)",
            "    {",
            "        ll lenPatternMatch = 0,",
            "           textIndex = 0;",
            "        v matches;",
            "",
            "        while (textIndex < sz(text))",
            "        {",
            "            // cout << lenPatternMatch << \" \" << textIndex << endl;",
            "            if (text[textIndex] == pattern[lenPatternMatch])",
            "            {",
            "                lenPatternMatch++;",
            "                textIndex++;",
            "                if (lenPatternMatch == sz(pattern))",
            "                {",
            "                    matches.push_back(textIndex - lenPatternMatch + 1);",
            "                    lenPatternMatch = lps[lenPatternMatch - 1];",
            "                }",
            "            }",
            "            else",
            "            {",
            "                if (lenPatternMatch > 0)",
            "                    lenPatternMatch = lps[lenPatternMatch - 1];",
            "                else",
            "                    textIndex++;",
            "            }",
            "        }",
            "",
            "        return move(matches);",
            "    }",
            "",
            "    ll count(const C &text)",
            "    {",
            "        return sz(getMatchIndices(text));",
            "    }",
            "",
            "    bool matches(const C &text)",
            "    {",
            "        return count(text) > 0;",
            "    }",
            "};"
        ]
    },
    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "// ONE INDEXED, independent nodes given by weights[i] <= 0",
            "v weights(5e5, 0);",
            "",
            "ll finder(ll v1)",
            "{",
            "    if (weights[v1] > 0)",
            "        weights[v1] = finder(weights[v1]);",
            "    if (weights[v1] > 0)",
            "        return weights[v1];",
            "    return v1;",
            "}",
            "",
            "void unioner(ll v1, ll v2)",
            "{",
            "    v1 = finder(v1);",
            "    v2 = finder(v2);",
            "",
            "    if (-weights[v1] >= -weights[v2])",
            "    {",
            "        weights[v1] += weights[v2] - 1;",
            "        weights[v2] = v1;",
            "    }",
            "    else",
            "    {",
            "        weights[v2] += weights[v1] - 1;",
            "        weights[v1] = v2;",
            "    }",
            "}",
            "",
            "bool addEdge(ll v1, ll v2, spll &edges)",
            "{",
            "    ll x1 = finder(v1),",
            "        x2 = finder(v2);",
            "    if (x1 != x2)",
            "    {",
            "        edges.insert({v1, v2});",
            "        unioner(x1, x2);",
            "        return true;",
            "    }",
            "    return false;",
            "}"
        ]
    },
    "graphinput": {
        "prefix": "graphinput",
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vv adjList(n + 1, v(0));",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b;",
            "    cin >> a >> b;",
            "    adjList[a].push_back(b);",
            "    adjList[b].push_back(a);",
            "}"
        ]
    },
    "graphinputweighted": {
        "prefix": "graphinputw",
        "body": [
            "ll n, m;",
            "cin >> n >> m;",
            "",
            "vspll adjList(n + 1);",
            "for (ll i = 0; i < m; i++)",
            "{",
            "    ll a, b, c;",
            "    cin >> a >> b >> c;",
            "    adjList[a].insert({b, c});",
            "    adjList[b].insert({a, c});",
            "}"
        ]
    },
    "toposort": {
        "prefix": "toposort",
        "body": [
            "queue<ll> degrees;",
            "for (ll i = 1; i <= n; i++)",
            "    if (!indeg[i])",
            "        degrees.push(i);",
            "v toposort = {};",
            "while (!degrees.empty())",
            "{",
            "    auto node = degrees.front();",
            "    degrees.pop();",
            "    toposort.push_back(node);",
            "    for (auto neigh : adjList[node])",
            "    {",
            "        indeg[neigh]--;",
            "        if (!indeg[neigh])",
            "            degrees.push(neigh);",
            "    }",
            "}"
        ]
    },
    "djikstra": {
        "prefix": "djikstra",
        "body": [
            "priority_queue<pll, vector<pll>, greater<pll>> q;",
            "v parent(5e5, -1);",
            "v distances(5e5, 1e15);",
            "vb visited(5e5, false);",
            "void djikstra(ll src, const vspll &adjList)",
            "{",
            "    distances[src] = 0;",
            "    q.push({0, src});",
            "    ll n = sz(adjList) - 1;",
            "",
            "    while (!q.empty())",
            "    {",
            "        auto x = q.top();",
            "        auto node = x.second;",
            "        auto d = distances[node];",
            "        q.pop();",
            "",
            "        if (visited[node])",
            "            continue;",
            "        visited[node] = true;",
            "",
            "        for (const auto &neigh : adjList[node])",
            "        {",
            "            ll d2 = d + neigh.second;",
            "",
            "            if (distances[neigh.first] > d2)",
            "            {",
            "                distances[neigh.first] = d2;",
            "                parent[neigh.first] = node;",
            "                q.push({d2, neigh.first});",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "shortest path tree": {
        "prefix": "sptree",
        "body": [
            "vv sptree(n + 1);",
            "for (ll i = 1; i <= n; i++)",
            "{",
            "    if (parent[i])",
            "    {",
            "        sptree[i].push_back(parent[i]);",
            "        sptree[parent[i]].push_back(i);",
            "    }",
            "}"
        ]
    },
    "dfs if part of cycle": {
        "prefix": "dfspartofcycle",
        "body": [
            "#define MAX (ll)3e5",
            "v visited(MAX, 0);",
            "v partofcycle(MAX, 0);",
            "v cyclenodes;",
            "bool dfs(vv &adjList, ll curr, ll prev)",
            "{",
            "    visited[curr] = 1;",
            "    for (auto neigh : adjList[curr])",
            "    {",
            "        if (neigh == prev)",
            "            continue;",
            "        if (visited[neigh] == 0)",
            "        {",
            "            if (dfs(adjList, neigh, curr))",
            "            {",
            "                partofcycle[curr] = true;",
            "                if (curr == cyclenodes.back())",
            "                {",
            "                    cyclenodes.pop_back();",
            "                    return false;",
            "                }",
            "                else",
            "                    return true;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            partofcycle[curr] = true;",
            "            cyclenodes.push_back(neigh);",
            "            return true;",
            "        }",
            "    }",
            "    return false;",
            "}"
        ]
    },
    "seg tree basic stuff": {
        "prefix": "segtree",
        "body": [
            "void build(v &tree, v &arr, ll rL, ll rR, ll idx, ll treeIdx) {",
            "    if (rL == rR) {",
            "        tree[treeIdx] = arr[idx];",
            "    } else {",
            "        ll mid = rL + rR;",
            "        mid >>= 1;",
            "        build(tree, arr, rL, mid, idx, treeIdx << 1);",
            "        build(tree, arr, mid + 1, rR, idx, (treeIdx << 1) | 1);",
            "        tree[treeIdx] = max(tree[treeIdx << 1], tree[(treeIdx << 1) | 1]);",
            "    }",
            "}",
            "",
            "void update(v &tree, ll rL, ll rR, ll treeIdx, ll val) {",
            "    if (rL == rR) {",
            "        tree[treeIdx] = val;",
            "    } else {",
            "        ll mid = rL + rR;",
            "        mid >>= 1;",
            "        update(tree, rL, mid, treeIdx << 1, val);",
            "        update(tree, mid + 1, rR, (treeIdx << 1) | 1, val);",
            "        tree[treeIdx] = max(tree[treeIdx << 1], tree[(treeIdx << 1) | 1]);",
            "    }",
            "}",
            "",
            "ll query(v &tree, ll rL, ll rR, ll qL, ll qR, ll treeIdx) {",
            "    if (rL >= qL && rR <= qR) {",
            "        return tree[treeIdx];",
            "    }",
            "    ll mid = rL + rR;",
            "    mid >>= 1;",
            "    return max(query(tree, rL, mid, qL, qR, treeIdx << 1),",
            "                query(tree, mid + 1, rR, qL, qR, (treeIdx << 1) | 1));",
            "}"
        ]
    },
    "matrix class": {
        "body": [
            "class Matrix {",
            "   public:",
            "    vv mat;",
            "    ll rows, cols;",
            "    Matrix(const vv &res) {",
            "        mat = res;",
            "        rows = sz(res);",
            "        cols = sz(res[0]);",
            "    }",
            "    // row matrix",
            "    Matrix(const v &res) {",
            "        rows = 1;",
            "        cols = sz(res);",
            "        mat = vv(1);",
            "        mat[0] = res;",
            "    }",
            "    Matrix(ll n, ll m) {",
            "        rows = n;",
            "        cols = m;",
            "        mat = vv(n, v(m, 0));",
            "    }",
            "    Matrix(ll n) {",
            "        rows = cols = n;",
            "        mat = vv(n, v(n, 0));",
            "    }",
            "    Matrix() {",
            "        rows = cols = 0;",
            "        mat = vv(0);",
            "    }",
            "",
            "    v &operator[](ll index) { return mat[index]; }",
            "",
            "    /**",
            "     * Multiply two matrixes",
            "     * nxp,pxm",
            "     */",
            "",
            "    Matrix matMult(Matrix &mat2, ll mod) {",
            "        vv res(rows, v(mat2.cols, 0));",
            "",
            "        for (ll i = 0; i < rows; i++) {",
            "            for (ll j = 0; j < mat2.cols; j++) {",
            "                for (ll k = 0; k < cols; k++) {",
            "                    res[i][j] += (mat[i][k] * mat2[k][j]) % mod;",
            "                    res[i][j] %= mod;",
            "                }",
            "            }",
            "        }",
            "        return Matrix(res);",
            "    }",
            "",
            "    Matrix matMult(vv &mat2, ll mod) {",
            "        Matrix obj = Matrix(mat2);",
            "        return matMult(obj, mod);",
            "    }",
            "",
            "    Matrix square(ll mod) { return matMult(mat, mod); }",
            "",
            "    /**",
            "     * Mod the elements of the matrix",
            "     */",
            "    void modMatrix(ll mod) {",
            "        for (ll i = 0; i < rows; i++) {",
            "            for (ll j = 0; j < cols; j++) {",
            "                mat[i][j] %= mod;",
            "            }",
            "        }",
            "    }",
            "",
            "    /**",
            "     * returns identity matrix of size nxn",
            "     */",
            "    static Matrix idMatrix(ll n) {",
            "        Matrix res(n);",
            "        for (ll i = 0; i < n; i++) {",
            "            res[i][i] = 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    Matrix transpose() {",
            "        Matrix res(cols, rows);",
            "        for (ll i = 0; i < cols; i++) {",
            "            for (ll j = 0; j < rows; j++) {",
            "                res[i][j] = mat[j][i];",
            "            }",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "    /**",
            "     * Only for square matrices",
            "     */",
            "    Matrix pomod(ll power, ll mod) {",
            "        Matrix res = Matrix::idMatrix(rows);",
            "        Matrix x = *this;",
            "",
            "        while (power > 0) {",
            "            if (power & 1)",
            "                res = res.matMult(x, mod);",
            "            power = power >> 1;",
            "            x = x.square(mod);",
            "        }",
            "",
            "        return res;",
            "    }",
            "",
            "    void print() {",
            "        for (ll i = 0; i < rows; i++) {",
            "            for (ll j = 0; j < cols; j++) {",
            "                cout << mat[i][j] << \" \";",
            "            }",
            "            cout << endl;",
            "        }",
            "    }",
            "};"
        ],
        "prefix": "matrix"
    },
    "recurrence relations ke liye": {
        "body": [
            "/**",
            "    * Given the number of known terms (k), the coefficients",
            "    * for the recurrence c_1*f_(n-1) + c_2*f_(n-2) + c_3*f_(n-3) + ...",
            "    * produces a method that can find the n-th term for yuo",
            "    * in k^3 log n time",
            "*/",
            "class Recurrence {",
            "   public:",
            "    ll k;",
            "    // transofmration kxk matrix T",
            "    Matrix T;",
            "    // kx1 matrix F = last k terms",
            "    Matrix F;",
            "",
            "    Recurrence(ll k, v initial, v coeffs) {",
            "        this->k = k;",
            "        Matrix mat(initial);",
            "        this->F = mat.transpose();",
            "",
            "        this->T = Matrix(k, k);",
            "        for (ll i = 0; i < k - 1; i++) {",
            "            this->T[i][i + 1] = 1;",
            "        }",
            "        // last terms coefficient should come first",
            "        reverse(all(coeffs));",
            "        this->T[k - 1] = coeffs;",
            "    }",
            "",
            "    ll nthterm(ll n) {",
            "        if (n <= k) {",
            "            return this->F[n - 1][0];",
            "        }",
            "",
            "        ll power = n - k;",
            "        // now raise T to that power",
            "        Matrix ansT = this->T.pomod(power, MOD);",
            "        // now mult T with",
            "        return ansT.matMult(this->F, MOD)[k - 1][0];",
            "    }",
            "};"
        ],
        "prefix": "recurrence"
    },
    "sum segment tree": {
        "body": [
            "pll add(pll a, pll b) { return {a.first + b.first, a.second + b.second}; }",
            "",
            "// handles both sum and count of elements present in that range",
            "void build(vpll &tree, ll rL, ll rR, ll treeIdx, ll val) {",
            "    if (rL == rR) {",
            "        tree[treeIdx] = {val, 1};",
            "    } else {",
            "        ll mid = rL + rR;",
            "        mid >>= 1;",
            "        build(tree, rL, mid, treeIdx << 1, val);",
            "        build(tree, mid + 1, rR, (treeIdx << 1) | 1, val);",
            "        tree[treeIdx] = add(tree[treeIdx << 1], tree[(treeIdx << 1) | 1]);",
            "    }",
            "}",
            "",
            "void update(vpll &tree, ll rL, ll rR, ll treeIdx, ll pos, ll val) {",
            "    if (rL == rR) {",
            "        if (pos == rL)",
            "            tree[treeIdx] = {val, 1};",
            "    } else {",
            "        ll mid = rL + rR;",
            "        mid >>= 1;",
            "        if (pos <= mid)",
            "            update(tree, rL, mid, treeIdx << 1, pos, val);",
            "        else",
            "            update(tree, mid + 1, rR, (treeIdx << 1) | 1, pos, val);",
            "        tree[treeIdx] = add(tree[treeIdx << 1], tree[(treeIdx << 1) | 1]);",
            "    }",
            "}",
            "",
            "pll query(vpll &tree, ll rL, ll rR, ll qL, ll qR, ll treeIdx) {",
            "    if (rL >= qL && rR <= qR) {",
            "        return tree[treeIdx];",
            "    }",
            "    if (qR < rL || qL > rR)",
            "        return {0, 0};",
            "",
            "    ll mid = (rL + rR) / 2;",
            "    pll q1 = query(tree, rL, mid, qL, qR, treeIdx << 1);",
            "    pll q2 = query(tree, mid + 1, rR, qL, qR, (treeIdx << 1) | 1);",
            "    return add(q1, q2);",
            "}"
        ],
        "prefix": "sumsegtree"
    },
    "bianry lifting": {
        "prefix": "binarylifting",
        "body": [
            "// -1 indicates DNE",
            "ll lim = 32;",
            "vv parents(3e5, v(lim, -1));",
            "",
            "void dfs2(ll curr = 1, ll prev = -1, ll depth = 1) {",
            "    levels[curr] = depth;",
            "    for (auto neigh : adjList[curr]) {",
            "        if (neigh == prev)",
            "            continue;",
            "        parents[neigh][0] = curr;",
            "        dfs2(neigh, curr, depth + 1);",
            "    }",
            "}",
            "",
            "void buildparents() {",
            "    for (ll power = 1; power < lim; power++) {",
            "        for (ll node = 1; node <= n; node++) {",
            "            ll halfway = parents[node][power - 1];",
            "            if (halfway != -1)",
            "                parents[node][power] = parents[halfway][power - 1];",
            "        }",
            "    }",
            "}",
            "",
            "ll lca(ll n1, ll n2) {",
            "    // assume n1 is lower level than n2",
            "    if (levels[n1] < levels[n2]) {",
            "        ll tmp = n1;",
            "        n1 = n2;",
            "        n2 = tmp;",
            "    }",
            "",
            "    // find the ancestor of n1 which is at the same level as n2",
            "    for (ll i = lim - 1; i >= 0; i--) {",
            "        if (levels[n1] - pow(2, i) >= levels[n2]) {",
            "            n1 = parents[n1][i];",
            "        }",
            "    }",
            "",
            "    if (n1 == n2) {",
            "        return n2;",
            "    }",
            "",
            "    // use binary jumping now",
            "    for (ll i = lim - 1; i >= 0; i--) {",
            "        ll x = parents[n1][i], y = parents[n2][i];",
            "        if (x != y && x != -1 && y != -1) {",
            "            n1 = x;",
            "            n2 = y;",
            "        }",
            "    }",
            "    return parents[n1][0];",
            "}"
        ]
    },
    "line container": {
        "prefix": "linecontainer",
        "body": [
            "/**",
            " * Author: Simon Lindholm",
            " * Date: 2017-04-20",
            " * License: CC0",
            " * Source: own work",
            " * Description: Container where you can add lines of the form kx+m, and query",
            " * maximum values at points x. Useful for dynamic programming. Time: O(log N)",
            " * Status: tested",
            " * To access individual elements of the linecontainer, simply use a for auto loop",
            " */",
            "",
            " struct Line {",
            "    mutable ll slope, constt, p;",
            "    bool operator<(const Line &o) const {",
            "        return slope < o.slope;",
            "    }",
            "    bool operator<(ll x) const {",
            "        return p < x;",
            "    }",
            "};",
            "",
            "#define IS_MAX_QUERY false",
            "struct LineContainer : multiset<Line, less<>> {",
            "    // (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "    const ll inf = LLONG_MAX;",
            "    ll div(ll a, ll b) {  // floored division",
            "        return a / b - ((a ^ b) < 0 && a % b);",
            "    }",
            "    bool isect(iterator x, iterator y) {",
            "        if (y == end()) {",
            "            x->p = inf;",
            "            return false;",
            "        }",
            "        if (x->slope == y->slope)",
            "            x->p = x->constt > y->constt ? inf : -inf;",
            "        else",
            "            x->p = div(y->constt - x->constt, x->slope - y->slope);",
            "        return x->p >= y->p;",
            "    }",
            "    void add(ll slope, ll constt) {",
            "        if (!IS_MAX_QUERY) {",
            "            slope = -slope;",
            "            constt = -constt;",
            "        }",
            "        auto z = insert({slope, constt, 0}), y = z++, x = y;",
            "        while (isect(y, z))",
            "            z = erase(z);",
            "        if (x != begin() && isect(--x, y))",
            "            isect(x, y = erase(y));",
            "        while ((y = x) != begin() && (--x)->p >= y->p)",
            "            isect(x, erase(y));",
            "    }",
            "    ll query(ll x) {",
            "        assert(!empty());",
            "        auto l = *lower_bound(x);",
            "        return (l.slope * x + l.constt) * (IS_MAX_QUERY ? 1 : -1);",
            "    }",
            "};"
        ],
        "description": "Line container from KTH notebook"
    },
    "ukonen tree": {
        "prefix": "suffixtrie",
        "body": [
            "/**",
            " * Author: Unknown",
            " * Date: 2017-05-15",
            " * Source: https://e-maxx.ru/algo/ukkonen",
            " * Description: Ukkonen's algorithm for online suffix tree construction.",
            " *  Each node contains indices [l, r) into the string, and a list of child",
            " * nodes. Suffixes are given by traversals of this tree, joining [l, r)",
            " * substrings. The root is 0 (has l = -1, r = 0), non-existent children are -1.",
            " *  To get a complete tree, append a dummy symbol -- otherwise it may contain",
            " *  an incomplete path (still useful for substring matching, though).",
            " * Time: $O(26N)$",
            " * Status: fuzz-tested a bit",
            " */",
            "",
            "struct SuffixTree {",
            "    enum { N = 200010, ALPHA = 26 };  // N ~ 2*maxlen+10",
            "    int toi(char c) {",
            "        return c - 'a';",
            "    }",
            "    string a;  // v = cur node, q = cur position",
            "    int t[N][ALPHA], l[N], r[N], p[N], s[N], v = 0, q = 0, m = 2;",
            "",
            "    void ukkadd(int i, int c) {",
            "    suff:",
            "        if (r[v] <= q) {",
            "            if (t[v][c] == -1) {",
            "                t[v][c] = m;",
            "                l[m] = i;",
            "                p[m++] = v;",
            "                v = s[v];",
            "                q = r[v];",
            "                goto suff;",
            "            }",
            "            v = t[v][c];",
            "            q = l[v];",
            "        }",
            "        if (q == -1 || c == toi(a[q]))",
            "            q++;",
            "        else {",
            "            l[m + 1] = i;",
            "            p[m + 1] = m;",
            "            l[m] = l[v];",
            "            r[m] = q;",
            "            p[m] = p[v];",
            "            t[m][c] = m + 1;",
            "            t[m][toi(a[q])] = v;",
            "            l[v] = q;",
            "            p[v] = m;",
            "            t[p[m]][toi(a[l[m]])] = m;",
            "            v = s[p[m]];",
            "            q = l[m];",
            "            while (q < r[m]) {",
            "                v = t[v][toi(a[q])];",
            "                q += r[v] - l[v];",
            "            }",
            "            if (q == r[m])",
            "                s[m] = v;",
            "            else",
            "                s[m] = m + 2;",
            "            q = r[v] - (q - r[m]);",
            "            m += 2;",
            "            goto suff;",
            "        }",
            "    }",
            "",
            "    SuffixTree(string a) : a(a) {",
            "        fill(r, r + N, sz(a));",
            "        memset(s, 0, sizeof s);",
            "        memset(t, -1, sizeof t);",
            "        fill(t[1], t[1] + ALPHA, 0);",
            "        s[0] = 1;",
            "        l[0] = l[1] = -1;",
            "        r[0] = r[1] = p[0] = p[1] = 0;",
            "        for (ll i = 0; i < sz(a); i++) {",
            "            ukkadd(i, toi(a[i]));",
            "        }",
            "    }",
            "",
            "    // example: find longest common substring (uses ALPHA = 28)",
            "    pll best;",
            "    int lcs(int node, int i1, int i2, int olen) {",
            "        if (l[node] <= i1 && i1 < r[node])",
            "            return 1;",
            "        if (l[node] <= i2 && i2 < r[node])",
            "            return 2;",
            "        int mask = 0, len = node ? olen + (r[node] - l[node]) : 0;",
            "        for (ll c = 0; c < ALPHA; c++)",
            "            if (t[node][c] != -1)",
            "                mask |= lcs(t[node][c], i1, i2, len);",
            "        if (mask == 3)",
            "            best = max(best, {len, r[node] - len});",
            "        return mask;",
            "    }",
            "    static pll LCS(string s, string t) {",
            "        SuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));",
            "        st.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);",
            "        return st.best;",
            "    }",
            "};"
        ]
    },
    "convex hull": {
        "prefix": "convexhull",
        "body": [
            "ld prod(const pld &a, const pld &b, const pld &c) {",
            "    return a.first * (b.second - c.second) + b.first * (c.second - a.second) +",
            "           c.first * (a.second - b.second);",
            "}",
            "",
            "bool cw(const pld &a, const pld &b, const pld &c) {",
            "    return prod(a, b, c) < 0;",
            "}",
            "",
            "bool ccw(const pld &a, const pld &b, const pld &c) {",
            "    return prod(a, b, c) > 0;",
            "}",
            "",
            "void convex_hull(vector<pld> &a) {",
            "    // remove duplicates",
            "    set<pll> s(all(a));",
            "    a = vector<pld>(all(s));",
            "",
            "    if (a.size() == 1)",
            "        return;",
            "",
            "    sort(all(a));",
            "    pld p1 = a[0], p2 = a.back();",
            "    vector<pld> up, down;",
            "    up.push_back(p1);",
            "    down.push_back(p1);",
            "    for (int i = 1; i < (int)a.size(); i++) {",
            "        if (i == a.size() - 1 || cw(p1, a[i], p2)) {",
            "            while (up.size() >= 2 &&",
            "                   !cw(up[up.size() - 2], up[up.size() - 1], a[i]))",
            "                up.pop_back();",
            "            up.push_back(a[i]);",
            "        }",
            "        if (i == a.size() - 1 || ccw(p1, a[i], p2)) {",
            "            while (down.size() >= 2 &&",
            "                   !ccw(down[down.size() - 2], down[down.size() - 1], a[i]))",
            "                down.pop_back();",
            "            down.push_back(a[i]);",
            "        }",
            "    }",
            "",
            "    a.clear();",
            "    for (int i = 0; i < (int)up.size(); i++)",
            "        a.push_back(up[i]);",
            "    for (int i = down.size() - 2; i > 0; i--)",
            "        a.push_back(down[i]);",
            "    reverse(all(a));",
            "}"
        ]
    }
}
